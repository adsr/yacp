--- origsrc/gdnsd-3.2.2/src/css.c	2020-02-19 22:56:40.000000000 +0900
+++ src/gdnsd-3.2.2/src/css.c	2020-02-23 14:58:06.868371200 +0900
@@ -939,7 +939,9 @@ static int make_tcp_listener_fd(gdnsd_an
     if (fd < 0)
         log_fatal("Failed to create TCP control socket: %s", logf_errno());
     sockopt_bool_fatal(TCP, addr, fd, SOL_SOCKET, SO_REUSEADDR, 1);
+#if defined(SO_REUSEPORT)
     sockopt_bool_fatal(TCP, addr, fd, SOL_SOCKET, SO_REUSEPORT, 1);
+#endif
     sockopt_bool_fatal(TCP, addr, fd, SOL_TCP, TCP_NODELAY, 1);
     if (bind(fd, &addr->sa, addr->len))
         log_fatal("bind() of TCP control socket %s failed: %s", logf_anysin(addr), logf_errno());
--- origsrc/gdnsd-3.2.2/src/dnsio_tcp.c	2020-02-19 22:56:40.000000000 +0900
+++ src/gdnsd-3.2.2/src/dnsio_tcp.c	2020-02-23 14:58:06.884003800 +0900
@@ -940,8 +940,9 @@ void tcp_dns_listen_setup(dns_thread_t*
     }
 
     sockopt_bool_fatal(TCP, sa, t->sock, SOL_SOCKET, SO_REUSEADDR, 1);
+#if defined(SO_REUSEPORT)
     sockopt_bool_fatal(TCP, sa, t->sock, SOL_SOCKET, SO_REUSEPORT, 1);
-
+#endif
     sockopt_bool_fatal(TCP, sa, t->sock, SOL_TCP, TCP_NODELAY, 1);
 
 #ifdef TCP_DEFER_ACCEPT
--- origsrc/gdnsd-3.2.2/src/dnsio_udp.c	2020-02-19 22:56:40.000000000 +0900
+++ src/gdnsd-3.2.2/src/dnsio_udp.c	2020-02-23 14:58:06.899615700 +0900
@@ -139,6 +139,8 @@ static void udp_sock_opts_v4(const gdnsd
     sockopt_int_fatal(UDP, sa, sock, SOL_IP, IP_MTU_DISCOVER, IP_PMTUDISC_DONT);
 #elif defined IP_DONTFRAG
     sockopt_bool_fatal(UDP, sa, sock, SOL_IP, IP_DONTFRAG, 0);
+#elif defined(__CYGWIN__)
+    log_fatal("IPv4 not supported: cannot disable DF/PMTUDISC");
 #else
 #   error IPv4 not supported: cannot disable DF/PMTUDISC
 #endif
@@ -176,6 +178,8 @@ static void udp_sock_opts_v6(const gdnsd
     const int min_mtu = IPV6_MIN_MTU;
     if (setsockopt(sock, SOL_IPV6, IPV6_MTU, &min_mtu, sizeof(min_mtu)) == -1)
         log_fatal("Failed to set IPV6_MTU on TCP socket: %s", logf_errno());
+#elif defined(__CYGWIN__)
+    log_fatal("IPv6 not ok: cannot set MTU to 1280");
 #else
 #   error IPv6 not ok: cannot set MTU to 1280
 #endif
@@ -226,7 +230,9 @@ void udp_sock_setup(dns_thread_t* t)
     }
 
     sockopt_bool_fatal(UDP, sa, t->sock, SOL_SOCKET, SO_REUSEADDR, 1);
+#if defined(SO_REUSEPORT)
     sockopt_bool_fatal(UDP, sa, t->sock, SOL_SOCKET, SO_REUSEPORT, 1);
+#endif
     if (addrconf->udp_rcvbuf)
         sockopt_int_fatal(UDP, sa, t->sock, SOL_SOCKET, SO_RCVBUF, (int)addrconf->udp_rcvbuf);
     if (addrconf->udp_sndbuf)
--- origsrc/gdnsd-3.2.2/src/main.c	2020-02-19 22:56:40.000000000 +0900
+++ src/gdnsd-3.2.2/src/main.c	2020-02-23 14:58:06.915241600 +0900
@@ -425,9 +425,11 @@ static css_t* runtime_execute(const char
     // init the stats code
     statio_init(socks_cfg->num_dns_threads);
 
+#if defined(MCL_CURRENT) && defined(MCL_FUTURE)
     // Lock whole daemon into memory, including all future allocations.
     if (gcfg->lock_mem && mlockall(MCL_CURRENT | MCL_FUTURE))
         log_fatal("mlockall(MCL_CURRENT|MCL_FUTURE) failed: %s (you may need to disabled the lock_mem config option if your system or your ulimits do not allow it)", logf_errno());
+#endif
 
     // init cookie support and load key, if any
     if (!gcfg->disable_cookies)
